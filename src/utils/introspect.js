import fs from "fs";
import path from "path";
import readline from "readline";
import { pool } from "@anclatechs/sql-buns";
import { generateChecksum } from "./generics.js";
import {
  SUPPORTED_SQL_DIALECTS,
  SUPPORTED_SQL_DIALECTS_TYPES,
} from "./constants.js";

const pkgPath = path.join(process.cwd(), "package.json");
const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
const userPath = pkg?.sqlBuns?.modelsPath;

const defaultPath = path.join(process.cwd(), "database", "models", "index.js");

const resolvedModelPath = userPath
  ? path.resolve(process.cwd(), userPath)
  : defaultPath;

if (!fs.existsSync(resolvedModelPath)) {
  throw new Error(
    `‚ùå Please create database/models/index.js in your root folder or set "sqlBuns.modelsPath" in package.json`
  );
}

const MIGRATIONS_DIR = path.join(process.cwd(), "migrations");
const SNAPSHOT_FILE = path.join(MIGRATIONS_DIR, "schema_snapshot.json");
const MODELS_PATH = resolvedModelPath;

/**
 * Prompt for confirmation before overwriting models/index.js
 */
async function confirmOverwrite(filePath) {
  if (!fs.existsSync(filePath)) return true;

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question(`${filePath} already exists. Overwrite? (y/N): `, (answer) => {
      rl.close();
      resolve(answer.trim().toLowerCase() === "y");
    });
  });
}

/**
 * Main inspectdb() function ‚Äî introspects existing DB and writes models/index.js
 */
export async function inspectdb() {
  console.log("üîç Inspecting connected database...");

  const dbType = process.env.DATABASE_ENGINE;

  let connection = null;
  const isPostgres = dbType === SUPPORTED_SQL_DIALECTS_TYPES.POSTGRES;
  const isMySQL = dbType === SUPPORTED_SQL_DIALECTS_TYPES.MYSQL;
  const isSQLite = dbType === SUPPORTED_SQL_DIALECTS_TYPES.SQLITE;
  const useConnection = isPostgres || isMySQL;

  if (isPostgres) {
    connection = await pool.connect();
  } else if (isMySQL) {
    connection = await pool.getConnection();
  }

  if (!SUPPORTED_SQL_DIALECTS.includes(dbType)) {
    throw new Error(
      `${dbType} DATABASE_ENGINE not supported. Review .env file.`
    );
  }

  console.log(`üì¶ Detected database: ${dbType}`);

  try {
    // Fetch all tables
    let tables = [];
    if (isPostgres) {
      const res = await connection.query(`
        SELECT table_name FROM information_schema.tables
        WHERE table_schema = 'public' AND table_type = 'BASE TABLE';
      `);
      tables = res.rows.map((r) => r.table_name);
    } else if (isMySQL) {
      const [rows] = await connection.query("SHOW TABLES;");
      tables = rows.map((r) => Object.values(r)[0]);
    } else if (isSQLite) {
      const res = await pool.all(
        "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';"
      );
      tables = res.map((r) => r.name);
    }

    if (tables.length === 0) {
      console.log("No tables found in this database.");
      return;
    }

    console.log(`üß± Found ${tables.length} tables: ${tables.join(", ")}`);

    // Step 1: Gather model schemas
    const schema = {};
    const dependencies = []; // store foreign key relationships temporarily

    for (const table of tables) {
      const model = await introspectTable(connection || pool, dbType, table);
      const fks = await introspectForeignKeys(
        connection || pool,
        dbType,
        table
      );

      // Collect dependency info ‚Äî don't assign yet
      for (const [refTable, rel] of Object.entries(fks)) {
        dependencies.push({
          parent: rel.model, // referenced table
          child: table, // table that holds the FK
          type: rel.type,
          foreignKey: rel.foreignKey,
          through: rel.through || null,
        });
      }

      schema[table] = { ...model, relations: {} };
    }

    // Step 2: Build only parent-side relations
    for (const dep of dependencies) {
      if (!schema[dep.parent]) continue;
      const parentRelations = schema[dep.parent].relations;

      // Assign relation only on the parent side
      parentRelations[dep.child] = {
        type: dep.type,
        model: dep.child,
        foreignKey: dep.foreignKey,
        ...(dep.through ? { through: dep.through } : {}),
      };
    }

    // Step 3: Continue your original flow
    const modelFile = buildModelFile(schema);

    const proceed = await confirmOverwrite(MODELS_PATH);
    if (!proceed) {
      console.log("üö´ Operation cancelled.");
      process.exit(0);
    }

    fs.writeFileSync(MODELS_PATH, modelFile);
    console.log(`‚úÖ Generated: ${MODELS_PATH}`);

    // Create baseline migration
    if (!fs.existsSync(MIGRATIONS_DIR)) fs.mkdirSync(MIGRATIONS_DIR);
    const baselineFile = path.join(
      MIGRATIONS_DIR,
      "0000_initial_bootstrap.sql"
    );
    fs.writeFileSync(
      baselineFile,
      `-- Baseline migration (auto-generated by inspectdb): ${new Date()}\n`
    );
    console.log(`üìú Created baseline migration: ${baselineFile}`);

    const checksum = generateChecksum(modelFile);
    await recordBaselineMigration(connection || pool, checksum);

    console.log("‚úÖ Inspectdb completed successfully.");
  } catch (err) {
    console.error("‚ùå Inspectdb failed:", err.message);
  } finally {
    if (useConnection) connection.release();
  }
}

/**
 * Introspect columns and constraints for a given table
 */
async function introspectTable(client, dbType, table) {
  const fields = {};

  if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.POSTGRES) {
    const res = await client.query(`
      SELECT column_name, data_type, is_nullable, column_default
      FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = '${table}';
    `);
    for (const col of res.rows) {
      fields[col.column_name] = {
        type: mapPgType(col.data_type),
        required: col.is_nullable === "NO",
        default: col.column_default || undefined,
      };
    }
  } else if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.MYSQL) {
    const [rows] = await client.query(`DESCRIBE \`${table}\`;`);
    for (const col of rows) {
      fields[col.Field] = {
        type: mapMySQLType(col.Type),
        required: col.Null === "NO",
        default: col.Default || undefined,
      };
    }
  } else if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.SQLITE) {
    const res = await client.all(`PRAGMA table_info(${table});`);
    for (const col of res) {
      fields[col.name] = {
        type: mapSQLiteType(col.type),
        required: col.notnull === 1,
        default: col.dflt_value || undefined,
      };
    }
  }

  return { name: table, fields };
}

/**
 * Extract foreign key relations
 */
async function introspectForeignKeys(client, dbType, table) {
  const foreignKeys = [];

  // 1Ô∏è‚É£ Gather FK metadata per dialect
  if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.POSTGRES) {
    const res = await client.query(`
      SELECT
        kcu.column_name AS fk_column,
        ccu.table_name AS ref_table,
        ccu.column_name AS ref_column,
        tc.constraint_name
      FROM information_schema.table_constraints AS tc
      JOIN information_schema.key_column_usage AS kcu
        ON tc.constraint_name = kcu.constraint_name
      JOIN information_schema.constraint_column_usage AS ccu
        ON ccu.constraint_name = tc.constraint_name
      WHERE tc.constraint_type = 'FOREIGN KEY'
        AND tc.table_name = '${table}';
    `);
    foreignKeys.push(...res.rows);
  } else if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.MYSQL) {
    const [rows] = await client.query(`
      SELECT
        COLUMN_NAME AS fk_column,
        REFERENCED_TABLE_NAME AS ref_table,
        REFERENCED_COLUMN_NAME AS ref_column,
        CONSTRAINT_NAME
      FROM information_schema.KEY_COLUMN_USAGE
      WHERE TABLE_NAME = '${table}' AND REFERENCED_TABLE_NAME IS NOT NULL;
    `);
    foreignKeys.push(...rows);
  } else if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.SQLITE) {
    const res = await client.all(`PRAGMA foreign_key_list(${table});`);
    for (const row of res) {
      foreignKeys.push({
        fk_column: row.from,
        ref_table: row.table,
        ref_column: row.to,
      });
    }
  }

  // No FKs
  if (foreignKeys.length === 0) return {};

  // 2Ô∏è‚É£ Detect if this is a join table
  const isJoinTable = await detectJoinTable(client, dbType, table, foreignKeys);

  // For join tables, just return enough info to mark them as "through"
  if (isJoinTable) {
    const [fk1, fk2] = foreignKeys;
    return {
      [fk1.ref_table]: {
        type: "manyToMany",
        model: fk1.ref_table,
        through: table,
        joinColumn: fk1.fk_column,
        inverseJoinColumn: fk2.fk_column,
      },
      [fk2.ref_table]: {
        type: "manyToMany",
        model: fk2.ref_table,
        through: table,
        joinColumn: fk2.fk_column,
        inverseJoinColumn: fk1.fk_column,
      },
    };
  }

  // 3Ô∏è‚É£ For normal FK tables, return minimal info (the direction is resolved later)
  const relations = {};
  for (const fk of foreignKeys) {
    const unique = await isColumnUnique(client, dbType, table, fk.fk_column);
    relations[fk.ref_table] = {
      type: unique ? "hasOne" : "hasMany",
      model: fk.ref_table,
      foreignKey: fk.fk_column,
      ref_column: fk.ref_column,
    };
  }

  return relations;
}

/**
 * Detects if table looks like a join table
 */
async function detectJoinTable(client, dbType, table, fks) {
  if (fks.length !== 2) return false;

  // check number of columns in table
  let columnCount = 0;
  if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.POSTGRES) {
    const res = await client.query(`
      SELECT COUNT(*) FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = '${table}';
    `);
    columnCount = parseInt(res.rows[0].count);
  } else if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.MYSQL) {
    const [rows] = await client.query(`SHOW COLUMNS FROM \`${table}\`;`);
    columnCount = rows.length;
  } else if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.SQLITE) {
    const res = await client.all(`PRAGMA table_info(${table});`);
    columnCount = res.length;
  }

  // If table has only 2-3 columns and both are FKs ‚Äî it's likely a join table
  return columnCount <= 3 && fks.length === 2;
}

/**
 * Checks if a column is unique or primary key
 */
async function isColumnUnique(client, dbType, table, column) {
  if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.POSTGRES) {
    const res = await client.query(`
      SELECT EXISTS (
        SELECT 1
        FROM information_schema.table_constraints tc
        JOIN information_schema.constraint_column_usage ccu
        ON tc.constraint_name = ccu.constraint_name
        WHERE tc.table_name = '${table}'
          AND (tc.constraint_type = 'UNIQUE' OR tc.constraint_type = 'PRIMARY KEY')
          AND ccu.column_name = '${column}'
      ) AS is_unique;
    `);
    return res.rows[0].is_unique;
  } else if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.MYSQL) {
    const [rows] = await client.query(`
      SHOW INDEX FROM \`${table}\` WHERE Column_name = '${column}' AND (Non_unique = 0);
    `);
    return rows.length > 0;
  } else if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.SQLITE) {
    const res = await client.all(`PRAGMA index_list(${table});`);
    for (const idx of res) {
      if (idx.unique) {
        const cols = await client.all(`PRAGMA index_info(${idx.name});`);
        if (cols.some((c) => c.name === column)) return true;
      }
    }
    return false;
  }
}

/**
 * Map DB-specific data types to your internal Field types
 */
function mapPgType(type) {
  if (type.includes("integer")) return "IntegerField";
  if (type.includes("numeric")) return "DecimalField";
  if (type.includes("text")) return "TextField";
  if (type.includes("character")) return "CharField";
  if (type.includes("boolean")) return "BooleanField";
  if (type.includes("timestamp")) return "DateTimeField";
  if (type.includes("date")) return "DateField";
  return "TextField";
}

function mapMySQLType(type) {
  if (type.includes("int")) return "IntegerField";
  if (type.includes("decimal")) return "DecimalField";
  if (type.includes("text")) return "TextField";
  if (type.includes("varchar")) return "CharField";
  if (type.includes("bool")) return "BooleanField";
  if (type.includes("datetime")) return "DateTimeField";
  return "TextField";
}

function mapSQLiteType(type) {
  const t = type.toLowerCase();
  if (t.includes("int")) return "IntegerField";
  if (t.includes("text")) return "TextField";
  if (t.includes("real")) return "DecimalField";
  if (t.includes("bool")) return "BooleanField";
  return "TextField";
}

/**
 * Generate the models/index.js file content
 */
function buildModelFile(schema) {
  let file = `import { defineModel, Fields } from "@anclatechs/sql-buns-migrate";\n\n`;

  for (const [table, def] of Object.entries(schema)) {
    file += `export const ${camelCase(def.name)} = defineModel("${
      def.name
    }", {\n`;
    for (const [col, info] of Object.entries(def.fields)) {
      file += `  ${col}: { type: Fields.${info.type}, required: ${info.required}`;
      if (info.default) file += `, default: "${info.default}"`;
      file += " },\n";
    }
    file += "}, {\n";

    if (Object.keys(def.relations).length) {
      file += "  relations: {\n";
      for (const [rel, info] of Object.entries(def.relations)) {
        file += `    ${rel}: { type: "${info.type}", model: "${info.model}", foreignKey: "${info.foreignKey}"`;

        // Only add "through" if it exists
        if (info.through) {
          file += `, through: "${info.through}"`;
        }

        file += " },\n";
      }
      file += "  },\n";
    }

    file += `  meta: { db_table: "${def.name}" }\n});\n\n`;
  }

  return file.trim() + "\n";
}

/**
 * Insert a baseline migration record
 */
async function recordBaselineMigration(client, checksum) {
  const dbType = process.env.DATABASE_ENGINE;
  const migrationName = "0000_initial_inspection.sql";

  // Create table
  if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.POSTGRES) {
    await client.query(`
      CREATE TABLE IF NOT EXISTS _sqlbuns_migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        checksum VARCHAR(64) NOT NULL,
        previous_checksum VARCHAR(64),
        direction VARCHAR(10) CHECK (direction IN ('up', 'down')) DEFAULT 'up' NOT NULL,
        applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        rolled_back BOOLEAN DEFAULT FALSE
      );
    `);
    await client.query(
      `INSERT INTO _sqlbuns_migrations (name, direction, checksum) VALUES ($1, $2, $3) ON CONFLICT (name) DO NOTHING;`,
      [migrationName, "up", checksum]
    );
  } else if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.MYSQL) {
    await client.query(`
      CREATE TABLE IF NOT EXISTS _sqlbuns_migrations (
        id INTEGER AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        checksum VARCHAR(64) NOT NULL,
        previous_checksum VARCHAR(64),
        direction VARCHAR(10) CHECK (direction IN ('up', 'down')) DEFAULT 'up' NOT NULL,
        applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        rolled_back BOOLEAN DEFAULT FALSE
      );
    `);
    await client.query(
      `INSERT INTO _sqlbuns_migrations (name, direction, checksum) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE checksum = checksum;`,
      [migrationName, "up", checksum]
    );
  } else if (dbType === SUPPORTED_SQL_DIALECTS_TYPES.SQLITE) {
    await client.run(`
      CREATE TABLE IF NOT EXISTS _sqlbuns_migrations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name VARCHAR(255) NOT NULL UNIQUE,
        checksum VARCHAR(64) NOT NULL,
        previous_checksum VARCHAR(64),
        direction VARCHAR(10) CHECK (direction IN ('up', 'down')) DEFAULT 'up' NOT NULL,
        applied_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        rolled_back INTEGER DEFAULT 0
      );
    `);
    await client.run(
      `INSERT OR IGNORE INTO _sqlbuns_migrations (name, direction, checksum) VALUES (?, ?, ?);`,
      [migrationName, "up", checksum]
    );
  }
}

function camelCase(str) {
  return str
    .split("_")
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join("");
}
